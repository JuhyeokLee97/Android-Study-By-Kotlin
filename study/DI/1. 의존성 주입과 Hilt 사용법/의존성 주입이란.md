# 의존성
### 의존성이란 어떤 대상이 참조하는 객체(또는 함수)를 의미한다.

``` kotlin
class Engine
class Car {
  val engine = Engine()
}
```
위 코드를 보면 Car(`대상`)는 Engine(`참조하는 객체`)에 의존한다.
그래서 Engine은 Car의 **의존성**이라고 말할 수 있다.

</br>
</br>
</br>
</br>

# 의존성 주입
### 의존성 주입이란 대상 객체(Client)에 의존성을 제공하는 기술이다.
``` kotlin
class Car {
  val engine = Engine()
}
```
위 코드에서는 Car 클래스에서 Engine을 직접 생성하고 있다.
다르게 말하면 Car 클래스는 Engine(의존성) **생성 책임**을 갖고 있다.

Engine 생성 책임을 없애려면 어떻게 해야할까?
Car는 외부에서 생성된 Engine을 전달 받으면 된다.
그러면 Car는 Engine 생성에 대한 책임이 없어지고 이러한 설계 패턴을 IoC(Inversion of Control, 제어의 역전)라고 한다.
즉, 객체 생성의 책임을 내부에서 외부로 역전하는 것이고 이것을 **의존성 주입**이라고 말한다.
``` kotlin
class Car(val engine: Engine) { ... }
```
위와 같이 Car 클래스를 작성하면 Car 클래스에서는 엔진이라는 의존성을 외부에서 주입받을 수 있도록 세팅하는 것이다.

</br>
</br>

### 의존성 주입 장점 1 - 재사용성 증가, 디커플링
``` kotlin
class Car(val engine: Engine) { ... }

fun main() {
  val gasolineCar = Car(GasolineEngine())
  val dieselCar = Car(DieselEngine())
}
```
위 코드처럼 Car는 Engine에 대해서 주입받도록 설계된 경우
다른 Engine을 갖는 Car를 생성하는 것에 대해서 Car 내부 코드를 수정하지 않아도 된다.
그러므로 **재사용성이 증가**하게 된다.
또한 Car 클래스 내부에서 Engine을 생성하지 않기 때문에 클래스(Engine)간 결합도가 느슨해지는 효과인 디커플링을 얻게 된다.

</br>
</br>

### 의존성 주입 장점 2 - 개발과 유지보수 간편성 증가
``` kotlin
class Car(
  val engine: Engine,
  val wheels: Wheels,
  val wiper: Wiper,
  val battery: Battery
) {
  // Car 비즈니스 로직만 담당
}
```
위 코드처럼 자동차에는 여러 파츠(엔진, 바퀴, 와이퍼, 배터리 등)가 필요하다.
Car 클래스가 이들을 직접 생성하지 않고 의존성을 주입받도록 설계하면,
Car를 담당하는 개발자는 Car의 핵심 비즈니스 로직에만 집중할 수 있다.
Car에 필요한 의존성(파츠)들을 주입받을 수 있도록 설계함으로써 Car 클래스를 담당하는 개발자는 Car의 비지니스 로직에만 집중할 수 있다.

또한 각 의존성이 단일 책임 원칙에 따라 독립적으로 캡슐화되어 있기 때문에,
하나의 의존성 변경이 다른 모듈에 영향을 주지 않는다.
이로써 협업 시 역할이 명확해지고, 유지보수가 간편해진다.

</br>
</br>

### 의존성 주입 장점 3 - 테스트 용이
``` kotlin
class CarTest {
  @Test
  fun `Car 성공 케이스 테스트`() {
    val car = Car(FakeEngine())
    ...
  }

  @Test
  fun `Car 실패 케이스 테스트`() {
    val car = Car(FakeBrokenEngine())
    ...
  }
}
```
위와 같이 테스트 코드를 작성해 테스트를 진행할 때, Car 클래스 내부는 수정하지 않아도 된다.
만약 Car 클래스에서 Engine 생성을 책임지고 있었다면 테스트하기 위해서는 다음과 같은 어려움을 갖게 된다.
- 테스트 환경에서 가짜(Fake)나 Mock 객체로 Engine을 교체할 수 없다.
- 실제 Engine이 네트워크나 DB 같은 외부 자원에 의존해서 실행 시간이 오래걸리나면, 테스트 실행 시 시간이 오래걸리거나 실패 가능성이 높아진다.
- Car 클래스 누배 코드 수정 없이 정상 케이스 / 오류 케이스를 분리하기 어렵다. (실패 케이스를 재현하기 위해서 Engine 생성 코드는 유지하고, Engine이 잘못 동작되도록 Car 내부 코드 수정이 필요할 수 있다.)

</br>
</br>
</br>
</br>

# Injector
### Injector는 의존성을 클라이언트에게 제공하는 역할을 한다.
#### Injector가 없는 경우
Injector가 없는 경우, main 함수에서 Engine 생성에 대한 책임을 갖는다.
``` kotlin
fun main() {
  val engine = Engine()
  val car = Car(engine)
}
```

</br>
</br>

#### Injector가 있는 경우
Injector가 있는 경우, main 함수에서 Engine 생성에 대한 책임을 갖지 않는다.
``` ktolin
class Injector() {
  fun getEngine() {
    return Engine()
  }
}

fun main() {
  val engine = Injector().getEngine()
  val car = Car(engine)
}
```

</br>

또한 동일한 Engine 인스턴스 참조가 가능하여 자원을 공유할 수 있다.
``` kotlin
class Injector() {
  val engine = Engine()
}

fun main() {
  val injector = Injector()
  val engine1 = injector.engine
  val engine2 = injector.engine
  val car1 = Car(engine1)
  val car2 = Car(engine2)
}
```

</br>
</br>
</br>
</br>

# 의존성 주입 장점 요약
### 1. 결합도를 낮춘다
클라이언트(Car)는 의존성 객체 구체 타입(GasolineEngine, DieselEngine)에 의존하지 않고, 추상 타입(Engine)에 의존하기 때문에 Engine 변경데 대한 영향이 작어진다.

</br>
</br>

### 2. 재사용성이 높아진다
의존성 객체 구체 타입(GasolineEngine, DiselEngine, FakeEngine)에 제약받지 않고 동일한 클라이언트(Car)를 변경없이 사용함으로써 다향성 기반에 재사용성이 증가한다.

</br>
</br>

### 3. 보일러플레이트 감소
반복적인 초기화 코드가 사라져 보일러프레이트가 감소된다.

</br>
</br>

### 4. 테스트가 쉽다
객체 내부를 변경하지 않고도 테스트 시나리오를 조작할 수 있다.

</br>
</br>

### 5. 의존성 관리가 용이하다
의존성 주입 개념과 Injector가 없는 경우, 각 객체가 의존 대상을 규칙 없이 새로 생성할 위험성이 크다.
이로 인해서 인스턴스가 중복 생성되서 메모리 낭비, 상태 공유 불가, 자원 누수 발생 가능성이 있다.
하지만 Injector를 이용해 의존성 생성 책임을 관리함으로써 위험성을 줄일 수 있다.
